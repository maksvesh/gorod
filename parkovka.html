<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –ü–∞—Ä–∫–æ–≤–∫–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        
        .header {
            text-align: center;
            padding: 10px;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        
        .game-container {
            display: flex;
            width: 100%;
            height: calc(100vh - 120px);
            position: relative;
        }
        
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .game-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        #gameCanvas {
            width: 100%;
            max-width: 800px;
            height: 400px;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 180px;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .steering-wheel {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid white;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .wheel-center {
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            position: relative;
        }
        
        .wheel-handle {
            position: absolute;
            width: 60px;
            height: 10px;
            background: white;
            border-radius: 5px;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
        }
        
        .pedals {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .pedal {
            width: 80px;
            height: 40px;
            background: linear-gradient(45deg, #ff4444, #ff6666);
            border: 2px solid white;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            touch-action: none;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .pedal:active {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .gas-pedal {
            background: linear-gradient(45deg, #4CAF50, #66bb6a);
        }
        
        .instructions {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            max-width: 800px;
            text-align: center;
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .notification {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            display: none;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .success-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(76, 175, 80, 0.3) 0%, transparent 70%);
            animation: successPulse 2s ease-in-out;
            display: none;
            z-index: 500;
            pointer-events: none;
        }
        
        @keyframes successPulse {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }
        
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            font-size: 24px;
        }
        
        .orientation-warning span {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) and (orientation: landscape) {
            body {
                height: 100vh;
                overflow: hidden;
            }
            
            .game-container {
                flex-direction: row;
                height: calc(100vh - 60px);
            }
            
            .game-area {
                flex: 1;
                height: 100%;
                justify-content: center;
            }
            
            #gameCanvas {
                height: calc(100vh - 240px);
                max-width: none;
                margin: 10px;
            }
            
            .mobile-controls {
                display: flex;
                height: 140px;
            }
            
            .game-ui {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                z-index: 100;
            }
            
            .instructions {
                display: none;
            }
            
            .header h1 {
                font-size: 20px;
            }
        }
        
        @media (max-width: 768px) and (orientation: portrait) {
            .orientation-warning {
                display: flex;
            }
        }
        
        @media (max-width: 480px) and (orientation: landscape) {
            .steering-wheel {
                width: 100px;
                height: 100px;
            }
            
            .pedal {
                width: 70px;
                height: 35px;
                font-size: 12px;
            }
            
            .mobile-controls {
                height: 120px;
                padding: 15px;
            }
            
            #gameCanvas {
                height: calc(100vh - 200px);
            }
            
            .stat-value {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>3D –ü–∞—Ä–∫–æ–≤–∫–∞</h1>
    </div>
    
    <div class="game-container">
        <div class="game-area">
            <div class="game-ui">
                <div class="stats">
                    <div class="stat">
                        <div>–û—á–∫–∏</div>
                        <div class="stat-value" id="score">0</div>
                    </div>
                    <div class="stat">
                        <div>–£—Ä–æ–≤–µ–Ω—å</div>
                        <div class="stat-value" id="level">1</div>
                    </div>
                </div>
                <div class="controls">
                    <button id="startButton">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                </div>
            </div>
            
            <canvas id="gameCanvas"></canvas>
            <div class="success-effect" id="successEffect"></div>
            
            <div class="instructions">
                –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è, –ø—Ä–æ–±–µ–ª –¥–ª—è —Ç–æ—Ä–º–æ–∂–µ–Ω–∏—è
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>
    
    <!-- –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
    <div class="mobile-controls" id="mobileControls">
        <div class="steering-wheel" id="steeringWheel">
            <div class="wheel-center"></div>
            <div class="wheel-handle"></div>
        </div>
        
        <div class="pedals">
            <div class="pedal gas-pedal" id="gasPedal">–ì–ê–ó</div>
            <div class="pedal" id="brakePedal">–¢–û–†–ú–û–ó</div>
        </div>
    </div>
    
    <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ–± –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ -->
    <div class="orientation-warning" id="orientationWarning">
        <span>üì±</span>
        <div>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ</div>
    </div>

    <!-- Three.js –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const gameCanvas = document.getElementById('gameCanvas');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const startButton = document.getElementById('startButton');
        const notification = document.getElementById('notification');
        const successEffect = document.getElementById('successEffect');
        const mobileControls = document.getElementById('mobileControls');
        const steeringWheel = document.getElementById('steeringWheel');
        const gasPedal = document.getElementById('gasPedal');
        const brakePedal = document.getElementById('brakePedal');
        const orientationWarning = document.getElementById('orientationWarning');

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let score = 0;
        let level = 1;
        let gameInterval;
        let gameActive = false;

        // Three.js –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer;
        let playerCar, targetParking;
        let obstacles = [];
        let parkingSpots = [];
        
        // –†–∞–∑–º–µ—Ä—ã –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        const FIELD_WIDTH = 40;
        const FIELD_HEIGHT = 30;
        
        // –†–∞–∑–º–µ—Ä—ã –º–∞—à–∏–Ω—ã
        const CAR_WIDTH = 2;
        const CAR_HEIGHT = 1;
        const CAR_LENGTH = 4;
        
        // –†–∞–∑–º–µ—Ä—ã –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–≥–æ –º–µ—Å—Ç–∞
        const PARKING_WIDTH = 3;
        const PARKING_LENGTH = 5;

        // –§–∏–∑–∏–∫–∞ –º–∞—à–∏–Ω—ã
        const carPhysics = {
            position: { x: 0, z: 0 },
            velocity: { x: 0, z: 0 },
            rotation: 0,
            speed: 0,
            maxSpeed: 0.3,
            acceleration: 0.02,
            deceleration: 0.05,
            steering: 0.04,
            braking: 0.1,
            wheelRotation: 0,
            maxWheelAngle: Math.PI / 3 // 60 –≥—Ä–∞–¥—É—Å–æ–≤
        };

        // –ö–ª–∞–≤–∏—à–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyS: false,
            KeyA: false,
            KeyD: false,
            Space: false
        };

        // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        const mobileInput = {
            steering: 0,
            gas: false,
            brake: false
        };

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ä—É–ª—è
        let isSteering = false;
        let wheelStartX = 0;
        let wheelCenterX = 0;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        function checkOrientation() {
            if (window.innerWidth < window.innerHeight) {
                orientationWarning.style.display = 'flex';
            } else {
                orientationWarning.style.display = 'none';
            }
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        function showNotification(text, type = 'info') {
            notification.textContent = text;
            notification.style.display = 'block';
            notification.style.background = type === 'success' ? 'rgba(76, 175, 80, 0.8)' : 'rgba(0, 0, 0, 0.8)';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç —É—Å–ø–µ—Ö–∞
        function showSuccessEffect() {
            successEffect.style.display = 'block';
            setTimeout(() => {
                successEffect.style.display = 'none';
            }, 2000);
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function setupMobileControls() {
            // –†—É–ª–µ–≤–æ–µ –∫–æ–ª–µ—Å–æ
            steeringWheel.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = steeringWheel.getBoundingClientRect();
                wheelCenterX = rect.left + rect.width / 2;
                wheelStartX = touch.clientX;
                isSteering = true;
                e.preventDefault();
            });

            steeringWheel.addEventListener('touchmove', (e) => {
                if (!isSteering) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - wheelStartX;
                const maxDelta = steeringWheel.offsetWidth / 2;
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ —Ä—É–ª—è
                let steeringValue = Math.max(-1, Math.min(1, deltaX / maxDelta));
                mobileInput.steering = steeringValue;
                
                // –í—Ä–∞—â–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ä—É–ª—è
                const rotation = steeringValue * carPhysics.maxWheelAngle * 2;
                steeringWheel.style.transform = `rotate(${rotation}rad)`;
                
                e.preventDefault();
            });

            steeringWheel.addEventListener('touchend', (e) => {
                isSteering = false;
                mobileInput.steering = 0;
                steeringWheel.style.transform = 'rotate(0rad)';
                e.preventDefault();
            });

            // –ü–µ–¥–∞–ª—å –≥–∞–∑–∞
            gasPedal.addEventListener('touchstart', (e) => {
                mobileInput.gas = true;
                gasPedal.style.background = 'linear-gradient(45deg, #2E7D32, #4CAF50)';
                e.preventDefault();
            });

            gasPedal.addEventListener('touchend', (e) => {
                mobileInput.gas = false;
                gasPedal.style.background = 'linear-gradient(45deg, #4CAF50, #66bb6a)';
                e.preventDefault();
            });

            // –ü–µ–¥–∞–ª—å —Ç–æ—Ä–º–æ–∑–∞
            brakePedal.addEventListener('touchstart', (e) => {
                mobileInput.brake = true;
                brakePedal.style.background = 'linear-gradient(45deg, #c62828, #ff4444)';
                e.preventDefault();
            });

            brakePedal.addEventListener('touchend', (e) => {
                mobileInput.brake = false;
                brakePedal.style.background = 'linear-gradient(45deg, #ff4444, #ff6666)';
                e.preventDefault();
            });

            // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É –º—ã—à–∏ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            steeringWheel.addEventListener('mousedown', (e) => {
                const rect = steeringWheel.getBoundingClientRect();
                wheelCenterX = rect.left + rect.width / 2;
                wheelStartX = e.clientX;
                isSteering = true;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isSteering) return;
                
                const deltaX = e.clientX - wheelStartX;
                const maxDelta = steeringWheel.offsetWidth / 2;
                
                let steeringValue = Math.max(-1, Math.min(1, deltaX / maxDelta));
                mobileInput.steering = steeringValue;
                
                const rotation = steeringValue * carPhysics.maxWheelAngle * 2;
                steeringWheel.style.transform = `rotate(${rotation}rad)`;
            });

            document.addEventListener('mouseup', () => {
                if (isSteering) {
                    isSteering = false;
                    mobileInput.steering = 0;
                    steeringWheel.style.transform = 'rotate(0rad)';
                }
            });

            gasPedal.addEventListener('mousedown', () => {
                mobileInput.gas = true;
                gasPedal.style.background = 'linear-gradient(45deg, #2E7D32, #4CAF50)';
            });

            gasPedal.addEventListener('mouseup', () => {
                mobileInput.gas = false;
                gasPedal.style.background = 'linear-gradient(45deg, #4CAF50, #66bb6a)';
            });

            brakePedal.addEventListener('mousedown', () => {
                mobileInput.brake = true;
                brakePedal.style.background = 'linear-gradient(45deg, #c62828, #ff4444)';
            });

            brakePedal.addEventListener('mouseup', () => {
                mobileInput.brake = false;
                brakePedal.style.background = 'linear-gradient(45deg, #ff4444, #ff6666)';
            });
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js —Å—Ü–µ–Ω—ã
        function initScene() {
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera = new THREE.PerspectiveCamera(75, gameCanvas.clientWidth / gameCanvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
            renderer = new THREE.WebGLRenderer({ 
                canvas: gameCanvas, 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(gameCanvas.clientWidth, gameCanvas.clientHeight);
            renderer.shadowMap.enabled = true;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
            createGameField();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—à–∏–Ω—ã –∏–≥—Ä–æ–∫–∞
            createPlayerCar();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
            createParkingSpots();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createObstacles();
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function initGame() {
            // –°–±—Ä–æ—Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            score = 0;
            level = 1;
            updateUI();
            
            // –û—á–∏—Å—Ç–∫–∞ —Å—Ü–µ–Ω—ã
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã
            initScene();
            
            gameActive = true;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        function createGameField() {
            // –ó–µ–º–ª—è
            const groundGeometry = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a7d3a });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // –ì—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è
            const borderGeometry = new THREE.BoxGeometry(FIELD_WIDTH, 1, 1);
            const borderMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
            const topBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            topBorder.position.set(0, 0.5, -FIELD_HEIGHT/2);
            scene.add(topBorder);
            
            // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
            const bottomBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            bottomBorder.position.set(0, 0.5, FIELD_HEIGHT/2);
            scene.add(bottomBorder);
            
            // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
            const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            leftBorder.rotation.y = Math.PI / 2;
            leftBorder.position.set(-FIELD_WIDTH/2, 0.5, 0);
            scene.add(leftBorder);
            
            // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
            const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
            rightBorder.rotation.y = Math.PI / 2;
            rightBorder.position.set(FIELD_WIDTH/2, 0.5, 0);
            scene.add(rightBorder);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—à–∏–Ω—ã –∏–≥—Ä–æ–∫–∞
        function createPlayerCar() {
            const carGroup = new THREE.Group();
            
            // –ö—É–∑–æ–≤ –º–∞—à–∏–Ω—ã
            const bodyGeometry = new THREE.BoxGeometry(CAR_WIDTH, CAR_HEIGHT, CAR_LENGTH);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.position.y = CAR_HEIGHT / 2;
            carGroup.add(body);
            
            // –ö–∞–±–∏–Ω–∞ –º–∞—à–∏–Ω—ã
            const cabinGeometry = new THREE.BoxGeometry(CAR_WIDTH * 0.8, CAR_HEIGHT * 0.8, CAR_LENGTH * 0.5);
            const cabinMaterial = new THREE.MeshLambertMaterial({ color: 0x4444ff });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.castShadow = true;
            cabin.position.set(0, CAR_HEIGHT, -CAR_LENGTH * 0.2);
            carGroup.add(cabin);
            
            // –ö–æ–ª–µ—Å–∞
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            // –ü–µ—Ä–µ–¥–Ω–∏–µ –∫–æ–ª–µ—Å–∞
            const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.rotation.z = Math.PI / 2;
            frontLeftWheel.position.set(-CAR_WIDTH/2, 0.2, CAR_LENGTH/3);
            carGroup.add(frontLeftWheel);
            
            const frontRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.rotation.z = Math.PI / 2;
            frontRightWheel.position.set(CAR_WIDTH/2, 0.2, CAR_LENGTH/3);
            carGroup.add(frontRightWheel);
            
            // –ó–∞–¥–Ω–∏–µ –∫–æ–ª–µ—Å–∞
            const rearLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearLeftWheel.rotation.z = Math.PI / 2;
            rearLeftWheel.position.set(-CAR_WIDTH/2, 0.2, -CAR_LENGTH/3);
            carGroup.add(rearLeftWheel);
            
            const rearRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearRightWheel.rotation.z = Math.PI / 2;
            rearRightWheel.position.set(CAR_WIDTH/2, 0.2, -CAR_LENGTH/3);
            carGroup.add(rearRightWheel);
            
            scene.add(carGroup);
            playerCar = carGroup;
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –º–∞—à–∏–Ω—ã
            carPhysics.position.x = -FIELD_WIDTH/2 + 5;
            carPhysics.position.z = -FIELD_HEIGHT/2 + 5;
            updateCarPosition();
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
        function createParkingSpots() {
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
            parkingSpots.forEach(spot => scene.remove(spot));
            parkingSpots = [];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è
            const spotsCount = 3 + level;
            
            for (let i = 0; i < spotsCount; i++) {
                const parkingGroup = new THREE.Group();
                
                // –ü–∞—Ä–∫–æ–≤–æ—á–Ω–æ–µ –º–µ—Å—Ç–æ
                const spotGeometry = new THREE.PlaneGeometry(PARKING_WIDTH, PARKING_LENGTH);
                const spotMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                spot.rotation.x = -Math.PI / 2;
                spot.receiveShadow = true;
                parkingGroup.add(spot);
                
                // –ì—Ä–∞–Ω–∏—Ü—ã –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–≥–æ –º–µ—Å—Ç–∞
                const borderGeometry = new THREE.BoxGeometry(PARKING_WIDTH, 0.1, 0.1);
                const borderMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                
                // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
                const topBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                topBorder.position.set(0, 0.05, PARKING_LENGTH/2);
                parkingGroup.add(topBorder);
                
                // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
                const bottomBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                bottomBorder.position.set(0, 0.05, -PARKING_LENGTH/2);
                parkingGroup.add(bottomBorder);
                
                // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
                const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                leftBorder.rotation.y = Math.PI / 2;
                leftBorder.position.set(-PARKING_WIDTH/2, 0.05, 0);
                parkingGroup.add(leftBorder);
                
                // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
                const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                rightBorder.rotation.y = Math.PI / 2;
                rightBorder.position.set(PARKING_WIDTH/2, 0.05, 0);
                parkingGroup.add(rightBorder);
                
                // –°–ª—É—á–∞–π–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
                let x, z;
                let validPosition = false;
                
                while (!validPosition) {
                    x = (Math.random() * (FIELD_WIDTH - PARKING_WIDTH - 10)) - (FIELD_WIDTH - PARKING_WIDTH - 10)/2;
                    z = (Math.random() * (FIELD_HEIGHT - PARKING_LENGTH - 10)) - (FIELD_HEIGHT - PARKING_LENGTH - 10)/2;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
                    const distance = Math.sqrt(
                        Math.pow(x - carPhysics.position.x, 2) + 
                        Math.pow(z - carPhysics.position.z, 2)
                    );
                    
                    if (distance > 10) {
                        validPosition = true;
                    }
                }
                
                parkingGroup.position.set(x, 0.01, z);
                scene.add(parkingGroup);
                parkingSpots.push(parkingGroup);
            }
            
            // –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –∫–∞–∫ —Ü–µ–ª–∏
            targetParking = parkingSpots[Math.floor(Math.random() * parkingSpots.length)];
            
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ü–µ–ª–µ–≤–æ–≥–æ –º–µ—Å—Ç–∞
            targetParking.children[0].material.color.set(0xffff00);
            targetParking.children[0].material.opacity = 1;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
        function createObstacles() {
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è
            const obstaclesCount = level;
            
            for (let i = 0; i < obstaclesCount; i++) {
                // –°–ª—É—á–∞–π–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                const width = 1 + Math.random() * 3;
                const height = 1 + Math.random() * 2;
                const depth = 1 + Math.random() * 3;
                
                const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
                const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                
                // –°–ª—É—á–∞–π–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
                let x, z;
                let validPosition = false;
                
                while (!validPosition) {
                    x = (Math.random() * (FIELD_WIDTH - width - 10)) - (FIELD_WIDTH - width - 10)/2;
                    z = (Math.random() * (FIELD_HEIGHT - depth - 10)) - (FIELD_HEIGHT - depth - 10)/2;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞ –∏ –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
                    const distanceToPlayer = Math.sqrt(
                        Math.pow(x - carPhysics.position.x, 2) + 
                        Math.pow(z - carPhysics.position.z, 2)
                    );
                    
                    let farEnoughFromSpots = true;
                    
                    for (const spot of parkingSpots) {
                        const spotX = spot.position.x;
                        const spotZ = spot.position.z;
                        const distanceToSpot = Math.sqrt(
                            Math.pow(x - spotX, 2) + 
                            Math.pow(z - spotZ, 2)
                        );
                        
                        if (distanceToSpot < 5) {
                            farEnoughFromSpots = false;
                            break;
                        }
                    }
                    
                    if (distanceToPlayer > 5 && farEnoughFromSpots) {
                        validPosition = true;
                    }
                }
                
                obstacle.position.set(x, height/2, z);
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º–∞—à–∏–Ω—ã
        function updateCarPosition() {
            playerCar.position.x = carPhysics.position.x;
            playerCar.position.z = carPhysics.position.z;
            playerCar.rotation.y = carPhysics.rotation;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        function updateUI() {
            scoreElement.textContent = score;
            levelElement.textContent = level;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        function checkCollisions() {
            if (!gameActive) return;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                const carBox = new THREE.Box3().setFromObject(playerCar);
                
                if (obstacleBox.intersectsBox(carBox)) {
                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ–º
                    showNotification('–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞', 'info');
                    resetCarPosition();
                    return;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–∫–æ–≤–∫–∏
            const parkingBox = new THREE.Box3().setFromObject(targetParking);
            const carBox = new THREE.Box3().setFromObject(playerCar);
            
            if (parkingBox.intersectsBox(carBox)) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –º–∞—à–∏–Ω—ã (–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞ –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–º—É –º–µ—Å—Ç—É)
                const angleDiff = Math.abs(carPhysics.rotation);
                const normalizedAngle = Math.abs((angleDiff + Math.PI) % (2 * Math.PI) - Math.PI);
                
                if (normalizedAngle < 0.5 || normalizedAngle > 5.8) { // –û–∫–æ–ª–æ 30 –≥—Ä–∞–¥—É—Å–æ–≤ –∏–ª–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –æ—Å—è–º
                    // –ú–∞—à–∏–Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø—Ä–∏–ø–∞—Ä–∫–æ–≤–∞–Ω–∞
                    score += 10 * level;
                    level++;
                    updateUI();
                    
                    showNotification(`–£—Å–ø–µ—à–Ω–∞—è –ø–∞—Ä–∫–æ–≤–∫–∞! –£—Ä–æ–≤–µ–Ω—å ${level}`, 'success');
                    showSuccessEffect();
                    
                    // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –º–∞—à–∏–Ω—ã –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –ø–∞—Ä–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Å—Ç
                    resetCarPosition();
                    createParkingSpots();
                    createObstacles();
                } else {
                    showNotification('–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –º–∞—à–∏–Ω—É –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–º—É –º–µ—Å—Ç—É', 'info');
                }
            }
        }

        // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –º–∞—à–∏–Ω—ã
        function resetCarPosition() {
            carPhysics.position.x = -FIELD_WIDTH/2 + 5;
            carPhysics.position.z = -FIELD_HEIGHT/2 + 5;
            carPhysics.velocity.x = 0;
            carPhysics.velocity.z = 0;
            carPhysics.rotation = 0;
            carPhysics.speed = 0;
            updateCarPosition();
        }

        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            if (!gameActive) return;
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∞—à–∏–Ω–æ–π (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ + –º–æ–±–∏–ª—å–Ω–æ–µ)
            let acceleration = 0;
            let steering = 0;
            
            // –£—Å–∫–æ—Ä–µ–Ω–∏–µ/—Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ + –º–æ–±–∏–ª—å–Ω–æ–µ)
            if (keys.ArrowUp || keys.KeyW || mobileInput.gas) {
                acceleration = carPhysics.acceleration;
            } else if (keys.ArrowDown || keys.KeyS) {
                acceleration = -carPhysics.acceleration;
            } else if (keys.Space || mobileInput.brake) {
                // –¢–æ—Ä–º–æ–∂–µ–Ω–∏–µ
                carPhysics.speed *= (1 - carPhysics.braking);
            } else {
                // –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ
                carPhysics.speed *= (1 - carPhysics.deceleration);
            }
            
            // –ü–æ–≤–æ—Ä–æ—Ç (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ + –º–æ–±–∏–ª—å–Ω–æ–µ)
            if (keys.ArrowLeft || keys.KeyA) {
                steering = carPhysics.steering;
            } else if (keys.ArrowRight || keys.KeyD) {
                steering = -carPhysics.steering;
            } else {
                // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä—É–ª–µ–º
                steering = -mobileInput.steering * carPhysics.steering;
            }
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–∑–∏–∫–∏
            carPhysics.speed += acceleration;
            carPhysics.speed = Math.max(-carPhysics.maxSpeed, Math.min(carPhysics.maxSpeed, carPhysics.speed));
            
            // –ü–æ–≤–æ—Ä–æ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏
            carPhysics.rotation += steering * (carPhysics.speed / carPhysics.maxSpeed);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            carPhysics.velocity.x = Math.sin(carPhysics.rotation) * carPhysics.speed;
            carPhysics.velocity.z = Math.cos(carPhysics.rotation) * carPhysics.speed;
            
            carPhysics.position.x += carPhysics.velocity.x;
            carPhysics.position.z += carPhysics.velocity.z;
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
            const halfCarWidth = CAR_WIDTH / 2;
            const halfCarLength = CAR_LENGTH / 2;
            
            carPhysics.position.x = Math.max(
                -FIELD_WIDTH/2 + halfCarWidth, 
                Math.min(FIELD_WIDTH/2 - halfCarWidth, carPhysics.position.x)
            );
            carPhysics.position.z = Math.max(
                -FIELD_HEIGHT/2 + halfCarLength, 
                Math.min(FIELD_HEIGHT/2 - halfCarLength, carPhysics.position.z)
            );
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –º–∞—à–∏–Ω—ã –≤ —Å—Ü–µ–Ω–µ
            updateCarPosition();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            checkCollisions();
        }

        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª Three.js
        function animate() {
            requestAnimationFrame(animate);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã (—Å–ª–µ–¥–∏—Ç –∑–∞ –º–∞—à–∏–Ω–æ–π)
            if (gameActive) {
                const carX = carPhysics.position.x;
                const carZ = carPhysics.position.z;
                
                camera.position.x = carX;
                camera.position.z = carZ + 15;
                camera.lookAt(carX, 0, carZ);
            }
            
            renderer.render(scene, camera);
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = false;
                e.preventDefault();
            }
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞ –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
        window.addEventListener('resize', () => {
            checkOrientation();
            if (camera && renderer) {
                camera.aspect = gameCanvas.clientWidth / gameCanvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(gameCanvas.clientWidth, gameCanvas.clientHeight);
            }
        });

        window.addEventListener('orientationchange', checkOrientation);

        startButton.addEventListener('click', () => {
            if (!gameActive) {
                initGame();
                gameActive = true;
                gameInterval = setInterval(gameLoop, 16); // ~60 FPS
                startButton.textContent = '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É';
                showNotification('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –ù–∞–π–¥–∏—Ç–µ –∂–µ–ª—Ç–æ–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–µ –º–µ—Å—Ç–æ', 'info');
            } else {
                // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏–≥—Ä—ã
                clearInterval(gameInterval);
                initGame();
                gameActive = true;
                gameInterval = setInterval(gameLoop, 16);
                showNotification('–ò–≥—Ä–∞ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω–∞!', 'info');
            }
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', () => {
            initScene();
            setupMobileControls();
            checkOrientation();
            showNotification('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ 3D –∏–≥—Ä—É "–ü–∞—Ä–∫–æ–≤–∫–∞"! –ù–∞–π–¥–∏—Ç–µ –∂–µ–ª—Ç–æ–µ –ø–∞—Ä–∫–æ–≤–æ—á–Ω–æ–µ –º–µ—Å—Ç–æ', 'info');
        });
    </script>
</body>
</html>